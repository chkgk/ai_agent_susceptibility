<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Grid</title>
    <style>
    :root { color-scheme: light dark; }
    body { display: grid; place-items: center; min-height: 100vh; margin: 0; }
    .card { padding: 1.25rem; border-radius: 16px; max-width: 540px; width: 100%; }
    img { width: 100%; height: auto; }
    button, input { padding: .6rem .9rem; border-radius: 10px; border: 1px solid #ccc; background: transparent; cursor: pointer; }
  </style>
</head>
<body>
  <div class="card">
    <img id="preview" alt="grid" />
  </div>

  <canvas id="c" width="332" height="332" style="display:none"></canvas>

  <script>
    // simple mulberry32 PRNG for reproducible seeds (client-side)
    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }

    function randint(rng, lo, hi) {
      // inclusive bounds
      return lo + Math.floor(rng() * (hi - lo + 1));
    }

    function sampleK(rng, N, k) {
      // return k unique integers from [0, N)
      const arr = Array.from({length: N}, (_, i) => i);
      // Fisherâ€“Yates partial shuffle
      for (let i = 0; i < k; i++) {
        const j = i + Math.floor(rng() * (N - i));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr.slice(0, k);
    }

     function drawGrid(opts = {}) {
      const n = 10;
      const cell = opts.cell ?? 80;
      const line = opts.line ?? 2;
      const total = n * n;

      // RNG setup
      let rng = Math.random;
      if (opts.seed !== undefined && opts.seed !== null && opts.seed !== "") {
        rng = mulberry32(Number(opts.seed) >>> 0);
      }

      // number of ones
      let k = opts.ones;
      if (k === undefined || k === null || k === "") k = randint(rng, 0, total);
      else k = Math.max(0, Math.min(total, Number(k)));

      // Canvas sizing (with devicePixelRatio for crisp text)
      const sizeCSS = n * cell + (n + 1) * line;
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const size = Math.floor(sizeCSS * dpr);

      const c = document.getElementById('c');
      c.width = size;
      c.height = size;
      c.style.width = sizeCSS + "px";
      c.style.height = sizeCSS + "px";

      const ctx = c.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale for HiDPI

      // background (white)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, sizeCSS, sizeCSS);

      // choose ones indices
      const onesIdx = new Set(sampleK(rng, total, k));

      // draw cells (no black fill, just text)
      // text settings
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#000000';
      ctx.font = `${Math.floor(cell * 0.6)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;

      for (let r = 0; r < n; r++) {
        for (let col = 0; col < n; col++) {
          const idx = r * n + col;
          const x = col * cell + (col + 1) * line;
          const y = r * cell + (r + 1) * line;

          // cell background stays white; we only draw the digit
          const cx = x + cell / 2;
          const cy = y + cell / 2;
          const digit = onesIdx.has(idx) ? '1' : '0';
          ctx.fillText(digit, cx, cy);
        }
      }

      // grid lines (light gray)
      ctx.fillStyle = '#cdcdcd';
      for (let i = 0; i <= n; i++) {
        const y = i * cell + i * line;
        ctx.fillRect(0, y, sizeCSS, line);
        const x = i * cell + i * line;
        ctx.fillRect(x, 0, line, sizeCSS);
      }

      // update preview
      document.getElementById('preview').src = c.toDataURL('image/png');
    }

    // initial draw
    drawGrid();
  </script>

</body>
</html>